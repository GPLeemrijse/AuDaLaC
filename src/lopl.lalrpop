use std::str::FromStr;
use crate::ast::*;
use lalrpop_util::ParseError;


grammar;

match {
    "Fix" => "Fix",
    "struct" => "struct",
    "if" => "if",
    "then" => "then",
    "null" => "null",
    "this" => "this",
    "String" => "String",
    "Nat" => "Nat",
    "Int" => "Int",
    "Bool" => "Bool",
    r#""[^"]*""# => STRING,
    r"(0|[1-9][0-9]*)" => NAT,
    r"-[1-9][0-9]*" => INT,
    r"(true|false)" => BOOL,
} else {
    r"[a-zA-Z][a-zA-Z0-9_]*(\.[a-zA-Z][a-zA-Z0-9_]*)*" => ID,
    _
}

Tier<Op, NextTier>: Box<Exp> = {
    <start:@L> <l:Tier<Op, NextTier>> <o:Op> <r:NextTier> <end:@R> => Box::new(Exp::BinOp(l, o, r, (start, end))),
    NextTier
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Var: Vec<String> = {
    ID => <>.to_string().split(".").map(str::to_string).collect()
}

// An identifier which throws a parse error when it contains "."
SimpleID : String = {
    ID =>? {
        if <>.contains(".") {
            Err(ParseError::User {
                error: "Expected Simple ID (= without '.')."
            })
        } else {
            Ok(<>.to_string())
        }
    },
}

pub Program: Program = <structs:Structs> <schedule:Schedule> => Program {<>};

pub Schedule: Box<Schedule> = {
    <start:@L> <s1:BottomSchedule> "<" <s2:Schedule> <end:@R> => Box::new(Schedule::Sequential(s1, s2, (start, end))),
    BottomSchedule
}

BottomSchedule: Box<Schedule> = {
    <start:@L> <id:ID> <end:@R> =>? {
        let parts : Vec<String> = id.to_string().split(".").map(str::to_string).collect();
        
        if parts.len() == 1 {
            Ok(Box::new(Schedule::StepCall(parts[0].clone(), (start, end))))
        } else if parts.len() == 2 {
            Ok(Box::new(Schedule::TypedStepCall(parts[0].clone(), parts[1].clone(), (start, end))))
        } else {
            Err(ParseError::User {
                error: "At most one dot is allowed in a step call."
            })
        }
    },
    <start:@L> "Fix" "(" <s:Schedule> ")" <end:@R> => Box::new(Schedule::Fixpoint(s, (start, end))),
}

Struct: Box<LoplStruct> = {
    <start:@L> "struct" <name:SimpleID>
    "(" <parameters:Pars> ")" 
    "{" <steps:Steps> "}" <end:@R> => Box::new(LoplStruct{name: name, parameters: parameters, steps: steps, loc: (start, end)})
}

Pars = Comma<Par>;
Par : (String, Type, Loc) = <start:@L> <id:SimpleID> ":" <t:Type> <end:@R> => (id, t, (start, end));

Step: Box<Step> = {
    <start:@L> <name:SimpleID> "{" <statements:Stats> "}" <end:@R> => Box::new(Step {name : name, statements: statements, loc : (start, end)})
}

pub Steps: Vec<Box<Step>> = Step*;
pub Structs: Vec<Box<LoplStruct>> = Struct+;

pub Stat: Box<Stat> = {
    "if" <start:@L> <e:Exp> <end:@R> "then" "{" <s:Stats> "}" => Box::new(Stat::IfThen(e, s, (start, end))),
    <start:@L> <t:Type> <id:SimpleID> ":=" <e:Exp> ";" <end:@R> => Box::new(Stat::Declaration(t, id, e, (start, end))),
    <start:@L> <v:Var> ":=" <e:Exp> ";" <end:@R> => Box::new(Stat::Assignment(v, e, (start, end))),
}

Stats = Stat*;
Type: Type = {
    "String" => Type::StringType,
    "Nat" => Type::NatType,
    "Int" => Type::IntType,
    "Bool" => Type::BoolType,
    SimpleID => Type::NamedType(<>)
}


// || operator has least precendence
pub Exp = Tier<OrOperator, AndExp>;
AndExp = Tier<AndOperator, EqExp>;
EqExp = Tier<EqualityOperator, CompExp>;
CompExp = Tier<CompareOperator, AddSubExp>;
AddSubExp = Tier<AddSubOperator, MultDivExp>;
MultDivExp = Tier<MultDivModOperator, NegExp>;
NegExp: Box<Exp> = {
    <start:@L> <o:NegationOperator> <e:NegExp> <end:@R> => Box::new(Exp::UnOp(o, e, (start, end))),
    BottomExp,
}

BottomExp: Box<Exp> = {
    <start:@L> "null" <end:@R> => Box::new(Exp::Lit(Literal::NullLit, (start, end))),
    <start:@L> "this" <end:@R> => Box::new(Exp::Lit(Literal::ThisLit, (start, end))),
    <start:@L> <e:NAT> <end:@R> => Box::new(Exp::Lit(Literal::NatLit(u32::from_str(e).expect("Could not convert to u32.")), (start, end))),
    <start:@L> <e:INT> <end:@R> => Box::new(Exp::Lit(Literal::IntLit(i32::from_str(e).expect("Could not convert to i32.")), (start, end))),
    <start:@L> <e:STRING> <end:@R> => Box::new(Exp::Lit(Literal::StringLit(e[1..e.len()-1].to_string()), (start, end))),
    <start:@L> <e:BOOL> <end:@R> => Box::new(Exp::Lit(Literal::BoolLit(e.parse().unwrap()), (start, end))),
    <start:@L> <id:SimpleID> "(" <e:Exps> ")" <end:@R> => Box::new(Exp::Constructor(id, e, (start, end))),
    <start:@L> <v:Var> <end:@R> => Box::new(Exp::Var(v, (start, end))),
    "(" <Exp> ")"
}

Exps = Comma<Exp>;


NegationOperator: UnOpcode = {
    "!" => UnOpcode::Negation
}

MultDivModOperator: BinOpcode = {
    "*" => BinOpcode::Mult,
    "/" => BinOpcode::Div,
    "%" => BinOpcode::Mod
}

AddSubOperator: BinOpcode = {
    "+" => BinOpcode::Plus,
    "-" => BinOpcode::Minus
}


CompareOperator: BinOpcode = {
    "<=" => BinOpcode::LessThanEquals,
    ">=" => BinOpcode::GreaterThanEquals,
    "<" => BinOpcode::LessThan,
    ">" => BinOpcode::GreaterThan,
}

EqualityOperator: BinOpcode = {
    "==" => BinOpcode::Equals,
    "!=" => BinOpcode::NotEquals,
}

AndOperator: BinOpcode = {
    "&&" => BinOpcode::And
}

OrOperator: BinOpcode = {
    "||" => BinOpcode::Or
}

Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
