use std::str::FromStr;
use crate::ast::*;
use lalrpop_util::ParseError;


grammar;

match {
    "Fix" => "Fix",
    "struct" => "struct",
    "if" => "if",
    "then" => "then",
    "null" => "null",
    "this" => "this",
    "String" => "String",
    "Nat" => "Nat",
    "Int" => "Int",
    "Bool" => "Bool",
    r#""[^"]*""# => STRING,
    r"(0|-?[1-9][0-9]*)" => NUM,
    r"(true|false)" => BOOL,
} else {
    r"[a-zA-Z][a-zA-Z0-9_]*(\.[a-zA-Z][a-zA-Z0-9_]*)*" => ID,
    _
}

Tier<Op, NextTier>: Box<Exp> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Exp::BinOp(<>)),
    NextTier
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Var: Vec<String> = {
    ID => <>.to_string().split(".").map(str::to_string).collect()
}

// An identifier which throws a parse error when it contains "."
SimpleID : String = {
    ID =>? {
        if <>.contains(".") {
            Err(ParseError::User {
                error: "Expected Simple ID (= without '.')."
            })
        } else {
            Ok(<>.to_string())
        }
    },
}

pub Program: Program = <structs:Structs> <schedule:Schedule> => Program {<>};

pub Schedule: Box<Schedule> = {
    <BottomSchedule> "<" <Schedule> => Box::new(Schedule::Sequential(<>)),
    BottomSchedule
}

BottomSchedule: Box<Schedule> = {
    ID =>? {
        let parts : Vec<String> = <>.to_string().split(".").map(str::to_string).collect();
        
        if parts.len() == 1 {
            Ok(Box::new(Schedule::StepCall(parts[0].clone())))
        } else if parts.len() == 2 {
            Ok(Box::new(Schedule::TypedStepCall(parts[0].clone(), parts[1].clone())))
        } else {
            Err(ParseError::User {
                error: "At most one dot is allowed in a step call."
            })
        }
    },
    "Fix" "(" <Schedule> ")" => Box::new(Schedule::Fixpoint(<>)),
}

Struct: Box<LoplStruct> = {
    "struct" <name:SimpleID> "(" <parameters:Pars> ")" "{" <steps:Steps> "}" => Box::new(LoplStruct{<>})
}

Pars = Comma<Par>;
Par : (String, Type, Loc) = <start:@L> <id:SimpleID> ":" <t:Type> <end:@R> => (id, t, (start, end));

Step: Box<Step> = {
    <start:@L> <name:SimpleID> "{" <statements:Stats> "}" <end:@R> => Box::new(Step {name : name, statements: statements, loc : (start, end)})
}

pub Steps: Vec<Box<Step>> = Step*;
pub Structs: Vec<Box<LoplStruct>> = Struct+;

pub Stat: Box<Stat> = {
    "if" <Exp> "then" "{" <Stats> "}" => Box::new(Stat::IfThen(<>)),
    <start:@L> <t:Type> <id:SimpleID> ":=" <e:Exp> ";" <end:@R> => Box::new(Stat::Declaration(t, id, e, (start, end))),
    <start:@L> <v:Var> ":=" <e:Exp> ";" <end:@R> => Box::new(Stat::Assignment(v, e, (start, end))),
}

Stats = Stat*;
Type: Type = {
    "String" => Type::StringType,
    "Nat" => Type::NatType,
    "Int" => Type::IntType,
    "Bool" => Type::BoolType,
    SimpleID => Type::NamedType(<>)
}


// || operator has least precendence
pub Exp = Tier<OrOperator, AndExp>;
AndExp = Tier<AndOperator, EqExp>;
EqExp = Tier<EqualityOperator, CompExp>;
CompExp = Tier<CompareOperator, AddSubExp>;
AddSubExp = Tier<AddSubOperator, MultDivExp>;
MultDivExp = Tier<MultDivModOperator, NegExp>;
NegExp: Box<Exp> = {
    NegationOperator NegExp => Box::new(Exp::UnOp(<>)),
    BottomExp,
}

BottomExp: Box<Exp> = {
    "null" => Box::new(Exp::Lit(Literal::NullLit)),
    "this" => Box::new(Exp::Lit(Literal::ThisLit)),
    NUM => Box::new(Exp::Lit(Literal::NumLit(i64::from_str(<>).unwrap()))),
    STRING => Box::new(Exp::Lit(Literal::StringLit(<>[1..<>.len()-1].to_string()))),
    BOOL => Box::new(Exp::Lit(Literal::BoolLit(<>.parse().unwrap()))),
    <SimpleID> "(" <Exps> ")" => Box::new(Exp::Constructor(<>)),
    Var => Box::new(Exp::Var(<>)),
    "(" <Exp> ")"
}

Exps = Comma<Exp>;


NegationOperator: UnOpcode = {
    "!" => UnOpcode::Negation
}

MultDivModOperator: BinOpcode = {
    "*" => BinOpcode::Mult,
    "/" => BinOpcode::Div,
    "%" => BinOpcode::Mod
}

AddSubOperator: BinOpcode = {
    "+" => BinOpcode::Plus,
    "-" => BinOpcode::Minus
}


CompareOperator: BinOpcode = {
    "<=" => BinOpcode::LessThanEquals,
    ">=" => BinOpcode::GreaterThanEquals,
    "<" => BinOpcode::LessThan,
    ">" => BinOpcode::GreaterThan,
}

EqualityOperator: BinOpcode = {
    "==" => BinOpcode::Equals,
    "!=" => BinOpcode::NotEquals,
}

AndOperator: BinOpcode = {
    "&&" => BinOpcode::And
}

OrOperator: BinOpcode = {
    "||" => BinOpcode::Or
}

Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
