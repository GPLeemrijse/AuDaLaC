
struct Node(p : Nat, owner : Bool, rho : Measure, candidate : Measure, max : Measure) {
	
	reset_candidate {
		if owner then {
			candidate.top := true;
			candidate.p1 := max.p1;
			candidate.p3 := max.p3;
		}

		if !owner then {
			candidate.top := false;
			candidate.p1 := 0;
			candidate.p3 := 0;
		}
	}

	max_candidate {
		Bool copy := false;
		if candidate.top then {
			copy := true;
		}
		if !candidate.top then {
			if candidate.p1 > rho.p1 then {
				copy := true;
			}
			if candidate.p1 <= rho.p1 then {
				if candidate.p3 > rho.p3 then {
					copy := true;
				}	
			}
		}

		if copy then {
			rho.top := candidate.top;
			rho.p1 := candidate.p1;
			rho.p3 := candidate.p3;
		}
	}
}

struct Edge(v : Node, w : Node, m : Measure, max : Measure) {

	prog {
		// m is (least) equivalent up to v.p to w.rho
		m.top := w.rho.top;

		if !m.top then {
			if v.p >= 1 then {
				m.p1 := w.rho.p1;
			}
			if v.p < 1 then {
				m.p1 := 0;
			}

			if v.p >= 3 then {
				m.p3 := w.rho.p3;
			}
			if v.p < 3 then {
				m.p3 := 0;
			}

			// Increase if Odd
			if v.p % 2 == 1 then {
				Bool incr := false;
					
				// Attempt to increase least significant measure
				if v.p >= 3 && m.p3 < max.p3 then {
					m.p3 := m.p3 + 1;
					incr := true;
				}
				// If not increased, check next priority.
				if !incr then {
					m.p3 := 0;
					// incrementing p1 possible
					if v.p >= 1 && m.p1 < max.p1 then {
						m.p1 := m.p1 + 1;
						incr := true;
					}
					// If p1 couldn't be incremented, Top is the only option.
					if !incr then {
						m.p1 := 0;
						m.top := true;
					}
				}
			}
		}
	}
	
	top {
		// if m is not top then the minimum candidate is also not top
		if v.owner && !m.top then {
			v.candidate.top := false;
		}

		// if m is not top then the maximum candidate is also top
		if !v.owner && m.top then {
			v.candidate.top := true;
		}
	}

	priority_1 {
		if !v.candidate.top then {
			if (v.owner  && m.p1 < v.candidate.p1) ||
			   (!v.owner && m.p1 > v.candidate.p1) then {
				v.candidate.p1 := m.p1;
			}
		}	
	}

	priority_3 {
		if !v.candidate.top && v.candidate.p1 == m.p1 then {
			if (v.owner  && m.p3 < v.candidate.p3) ||
			   (!v.owner && m.p3 > v.candidate.p3) then {
				v.candidate.p3 := m.p3;
			}
		}
	}
}

struct Measure(top : Bool, p1 : Nat, p3 : Nat) {
	init {
		Bool even := true;
		Bool odd := false;
		Measure max := Measure(false, 2, 3);

		Node X := Node(1, odd, Measure(false, 0, 0), Measure(false, 0, 0), max);
		Node X_p := Node(1, even, Measure(false, 0, 0), Measure(false, 0, 0), max);
		Node Y_p := Node(2, even, Measure(false, 0, 0), Measure(false, 0, 0), max);
		Node Y := Node(2, odd, Measure(false, 0, 0), Measure(false, 0, 0), max);
		Node W := Node(3, even, Measure(false, 0, 0), Measure(false, 0, 0), max);
		Node Z := Node(3, even, Measure(false, 0, 0), Measure(false, 0, 0), max);
		Node Z_p := Node(3, even, Measure(false, 0, 0), Measure(false, 0, 0), max);

		Edge e1 := Edge(X, X, Measure(false, 0, 0), max);
		Edge e2 := Edge(X, X_p, Measure(false, 0, 0), max);
		Edge e3 := Edge(X_p, Y, Measure(false, 0, 0), max);
		Edge e4 := Edge(X_p, Z, Measure(false, 0, 0), max);
		Edge e5 := Edge(Y, Y_p, Measure(false, 0, 0), max);
		Edge e6 := Edge(Y, W, Measure(false, 0, 0), max);
		Edge e7 := Edge(Y_p, Y, Measure(false, 0, 0), max);
		Edge e8 := Edge(Y_p, X, Measure(false, 0, 0), max);
		Edge e9 := Edge(W, W, Measure(false, 0, 0), max);
		Edge e10 := Edge(W, Z, Measure(false, 0, 0), max);
		Edge e11 := Edge(Z, Z_p, Measure(false, 0, 0), max);
		Edge e12 := Edge(Z_p, Z_p, Measure(false, 0, 0), max);
	}
}


init <
Node.print <
Fix (
	prog <
	reset_candidate <
	top <
	Fix(priority_1) <
	Fix(priority_3) <
	max_candidate
) <
Measure.print