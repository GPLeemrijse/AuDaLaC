$$__device__ uint nrof_odd_wins = 0;
//transformer -mm ~/repos/ModelChecking2/tests/testcases/dining/dining_9.invariantly_inevitably_eat.gm | pgsolver -global smallprog -dsd -dgo -dsg -dlo | grep "Chosen"

// V_diamond = even == false
// V_square = odd == true
struct Node(p: Nat,
			is_odd: Bool,
			dirty: Bool,
			rho_top: Bool,
			rho_1: Nat,
			rho_3: Nat,
			cand: Edge){
	lift {
		dirty := false;
		if cand != null then {
			// Copy candidate if it is lexicographically larger
			if (cand.prog_top != rho_top && cand.prog_top) ||
			   (cand.prog_top == rho_top && cand.prog_1 > rho_1) ||
			   (cand.prog_top == rho_top && cand.prog_1 == rho_1 && cand.prog_3 > rho_3) then {
				rho_top := cand.prog_top;
				rho_1 := cand.prog_1;
				rho_3 := cand.prog_3;
				dirty := true;
			}
		}
	}

	count_odd {
		if this != null && rho_top then {
			$$atomicInc(&nrof_odd_wins, 0xffffffff);
		}
	}

	print_odd {
		if this == null then {
			$$printf("Number of odd won vertices = %u\n", nrof_odd_wins);
		}
	}
}

struct Edge(v: Node,
			w: Node,
			max1: Nat,
			max3: Nat,
			prog_top: Bool,
			prog_1: Nat,
			prog_3: Nat) {
	prog {
		if w.dirty then {
			// Set m s.t. m =_p(v) rho(w)
			Bool m_top := w.rho_top;
			Nat m_1 := 0;
			if v.p >= 1 then {
				m_1 := w.rho_1;
			}
			Nat m_3 := 0;
			if v.p >= 3 then {
				m_3 := w.rho_3;
			}
			
			// Increase if v.p is odd
			if v.p % 2 == 1 then {
				Bool increased := m_top;// If m = T, then we're done already.
				
				if v.p >= 3 && !increased then {
					Nat new_3 := 0;
					if m_3 < max3 then {
						new_3 := m_3 + 1;
						increased := true;
					}
					m_3 := new_3;
				}

				if v.p >= 1 && !increased then {
					Nat new_1 := 0;
					if m_1 < max1 then {
						new_1 := m_1 + 1;
						increased := true;
					}
					m_1 := new_1;
				}
				if !increased then {
					m_top := true;
				}
			}

			// If we are w's candidate and we changed, a new vote is in order.
			if v.cand == this then {
				Bool changed := m_top != prog_top || prog_1 != m_1 || prog_3 != m_3;
				if changed then {
					v.cand := null;
				}
			}
			prog_top := m_top;
			prog_1 := m_1;
			prog_3 := m_3;
		}
	}

	minmax_top {
		if v.cand == null || (
			/*min*/	(!v.is_odd &&  v.cand.prog_top && !prog_top) ||
			/*max*/	( v.is_odd && !v.cand.prog_top &&  prog_top)
			) then {
			v.cand := this;
		}
	}

	minmax_1 {
		if v.cand.prog_top == prog_top && (
			/*min*/	(!v.is_odd && v.cand.prog_1 > prog_1) ||
			/*max*/	( v.is_odd && v.cand.prog_1 < prog_1)
			) then {
			v.cand := this;
		}
	}

	minmax_3 {
		if v.cand.prog_top == prog_top &&
		   v.cand.prog_1   == prog_1   && (
			/*min*/	(!v.is_odd && v.cand.prog_3 > prog_3) ||
			/*max*/	( v.is_odd && v.cand.prog_3 < prog_3)
			) then {
			v.cand := this;
		}
	}

	self_loops_to_top {
		if v == w && v.is_odd && v.p % 2 == 1 then {
			v.rho_top := true;
		}
	}
}

self_loops_to_top <
Fix(
	prog <
	Fix(minmax_top) <
	Fix(minmax_1) <
	Fix(minmax_3) <
	lift
)
 // < count_odd
 // < print_odd